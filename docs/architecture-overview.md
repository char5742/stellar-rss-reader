```plaintext
app/
 ┣ feed/
 ┃   ┣ domain/
 ┃   ┃   ┣ entities/
 ┃   ┃   ┣ services/
 ┃   ┃   ┗ events/
 ┃   ┣ application/
 ┃   ┃   ┣ useCases/
 ┃   ┃   ┗ subscribers/
 ┃   ┣ infrastructure/
 ┃   ┗ interface/
 ┃       ┣ router/
 ┃       ┣ components/
 ┃       ┣ hooks/
 ┃       ┣ store/
 ┃       ┗ pages/
 ┣ article/
 ┃   ┣ domain/
 ┃   ┣ application/
 ┃   ┣ infrastructure/
 ┃   ┗ interface/
 ┣ user/
 ┃   ┣ domain/
 ┃   ┣ application/
 ┃   ┣ infrastructure/
 ┃   ┗ interface/
 ┗ shared/
     ┣ domain/
     ┣ application/
     ┣ infrastructure/
     ┗ interface/
```

---

## 1. 機能ごとにディレクトリをまとめる狙い

- 「feed」「article」「user」といった**機能単位**（サブドメイン単位）でドメインからUIまで完結させる構成です。  
- 変更対象のフォルダを的確に絞れて保守が容易になり、複数機能で使い回す共通ロジックは `shared/` に置くことで重複を防ぎつつ、不要な肥大化を回避します。

---

## 2. 各フォルダの役割

### 2.1. domain

- **`domain/entities/`**  
  - エンティティ（集約ルート含む）や値オブジェクトを関数ベースで定義します。  
  - バリデーションや不変条件など「ビジネスルールの中心」をエンティティに閉じ込めてください。  
  - **クラスは使用せず、すべてfunctionで実装**し、immutabilityを意識します（`immer`や`ts-pattern`を活用）。

- **`domain/services/`**  
  - エンティティ同士のやり取りや、複雑なビジネスロジックを扱う**ドメインサービス**を関数で定義します。  
  - 単一エンティティで完結しない操作や、外部計算・統合を行う場合に利用します。

- **`domain/events/`**  
  - その機能に特化した**ドメインイベント**を定義します。  
  - `FeedCreatedEvent` / `FeedDeletedEvent`などを発行し、アプリケーション層に通知することで他集約や外部サービスとの連携を促します。

#### ポイント
1. エンティティは「ドメインルール・整合性」を保つ中心。  
2. **不変条件**はエンティティ生成関数や操作関数の中でチェックします。  
3. ドメインイベントはエンティティの関数またはユースケースで発行し、イベントベースで他コンテキストと連携します。  
4. **プリミティブ型を安易に使わず、独自型やブランド型（`Symbol`や`brand`）を定義**して混在を防ぎ、ドメインごとに型を切り分けてください。  
5. **異なるコンテキスト間ではドメイン型を直接参照せず、ID（ブランド化された型）のみ参照可能**とし、それ以外のデータはイベントで受け渡すようにしてください。  

---

### 2.2. application

- **`application/useCases/`**  
  - ユースケース単位のロジックを配置します。  
  - リポジトリを介してエンティティを操作し、必要に応じて**ドメインイベントを発行**します。  
  - ビジネスルールそのものは持たず、ドメイン層を呼び出す**オーケストレーション**を担います。  
  - ここで**永続化処理を直接呼ばない**ことが重要です（詳細は後述）。

- **`application/subscribers/`**  
  - ドメインイベントを購読し、外部サービスへの通知や他ドメイン連携を行います。  
  - イベント駆動で疎結合を保つため、ユースケース等から発行されたイベントをここでハンドリングします。

#### ポイント
1. ユースケースはアプリケーションサービスとして、ドメイン層の呼び出しとイベント発行を一手に管理します。  
2. トランザクション管理やイベント発行の契機を担い、複数のドメインサービスやリポジトリ呼び出しを組み合わせます。  
3. **永続化は行わず**、インフラへの呼び出しはしません（後述の方針を参照）。

---

### 2.3. infrastructure

- **外部サービス・DBとの通信やリポジトリ実装をまとめる層**です。  
- リポジトリインターフェイスは `domain/` 側（または`shared/domain/`）に定義し、実装はここに置きます。  
- ドメイン層に**実装の詳細を漏らさない**ようにし、ドメイン層からはインターフェイスを通してのみアクセスさせます。  

#### ポイント
1. **外部サービスやDBとの接続を隔離**し、ドメイン層から直接アクセスしない。  
2. リポジトリの実装を差し替えても、ドメイン層やユースケースに影響が及ばない。  
3. **永続化処理はあくまでインフラ層が担当**するという方針を守ります。

---

### 2.4. interface

- **`interface/router/`**  
  - ルーティングの定義をまとめます。React RouterやTanStack Routerなどを用いて、画面遷移を制御します。

- **`interface/components/`**  
  - UIコンポーネントを配置し、ユーザー操作→ユースケース呼び出しのフローを組み立てます。  
  - ロジックは可能な限りドメインやアプリケーション層に閉じ込め、UIは“見た目”と“アクションのきっかけ”に専念します。  
  - データ型には`type`や`Readonly<...>`を活用してください。

- **`interface/hooks/`**  
  - Reactのカスタムフックを配置。複数コンポーネントで共通するUIロジックなどを切り出します。  
  - こちらも状態や引数の型定義に`type`と`Readonly`を使い、**関数ベースで実装**してください。

- **`interface/store/`**  
  - グローバルなUI状態（Redux, Jotai, Recoilなど）の管理ロジックを置きます。  
  - ここで管理する状態はあくまで**UI専用**であり、ドメインエンティティそのものを保持しないように注意します。

- **`interface/pages/`**  
  - ルーティング単位のページコンポーネントを配置します。  
  - 大枠のレイアウトや、下位コンポーネントを呼び出す役割を担います。

#### ポイント
1. **UIレイヤーはドメインロジックを持たない。ユースケースの呼び出しのみ**に徹する。  
2. データ型やPropsは`interface`を使わず、基本的に`type`と`Readonly<...>`を用いて定義する。  
3. **永続化はここから直接`infrastructure`へ呼び出す**（アプリケーション層では行わない）設計とし、UI操作に応じて必要なら`infrastructure`の関数を実行します。

---

## 3. shared ディレクトリの使い方

- **`shared/domain/`**  
  - 複数機能で使い回す汎用的なドメインロジックや値オブジェクト、ユーティリティを定義します。  
  - 例: 日付や貨幣、共通ID生成関数などをブランド型/シンボル型で定義し、混在を防ぎます。

- **`shared/application/`**  
  - 全機能から共通して呼び出されるアプリケーション層のロジックがあれば置きますが、乱用注意です。  
  - 使い回しが実際に必要な最低限に絞り、**巨大化しないよう**注意してください。

- **`shared/infrastructure/`**  
  - ロガーやAPIクライアントなど、横断的なインフラ要素をまとめます。  
  - 例: Axiosインスタンス設定やAWS SDKの初期化、`rxjs`の共通設定など。

- **`shared/interface/`**  
  - 全体で共有するUI要素やフック、レイアウト、デザインシステム的コンポーネントを配置します。  
  - こちらも**不必要に肥大化しないよう**留意してください。

#### ポイント
1. 本当に複数機能で使うもののみを配置。  
2. ドメインごとに切り離しておきたいロジックは`shared`に入れない。  
3. sharedに置くドメインオブジェクトも**関数ベース**・**ブランド型**を意識し、他ドメインとの混在を避ける。

---

## 4. より良い運用のためのポイント

1. **ディレクトリ・ファイル命名の一貫性**  
   - 名前がブレると可読性が低下するため、チームでルールを定めて徹底します。

2. **依存方向を厳格に管理**  
   - ドメイン層からインフラ層を参照しない。  
   - リポジトリインターフェイスはドメイン層か`shared/domain/`に置き、実装はインフラ層。  
   - UIから永続化を呼ぶ場合も**インフラ層へ**のみアクセスし、アプリケーション層は経由しない形を守ります。

3. **ユースケースとUIイベントハンドラの結合度を下げる**  
   - Reactコンポーネント（UI）からユースケースを呼び出すだけにして、依存注入可能な設計（関数にパラメータでリポジトリを渡すなど）にしておくとテストが容易になります。

4. **ドメインイベント駆動で拡張性を高める**  
   - 例: `FeedCreatedEvent`を発行し、購読側でメール送信やログ記録を行う。  
   - 新たな機能追加も、購読ハンドラを追加するだけで完結し、既存ユースケースを変更せず済むことが多いです。

5. **ディレクトリを過度に細分化しない**  
   - 大規模になるほど細分化されがちですが、深すぎる階層は逆に混乱を招きやすいです。  
   - 必要最小限の深さを保ってください。

---

## 5. この構成のメリット

1. **機能ごとに“縦割り”で完結**  
   - ドメインからUIまでが1つのフォルダにまとまっており、変更範囲を把握しやすい。  
   - 新規機能追加時も同じパターンを踏襲しやすい。

2. **DDDのレイヤー分割と整合**  
   - domain / application / infrastructure / interface というレイヤーを機能単位で独立させられるため、ドメインロジックの独立性を保ちながらUIや外部実装との依存関係を明確にできます。

3. **疎結合と再利用の両立**  
   - 各機能ごとに閉じつつ、共通化が必要な要素だけを`shared/`に切り出せる。  
   - 過度な共通化を避け、必要なところだけ再利用する方針をとりやすい。

---

## 6. 実装上の追加方針

1. **クラスを使用せず、すべてfunctionのみで実装**してください。  
   - エンティティやドメインサービスも関数ベースとし、`immer`によるimmutable化や`ts-pattern`のパターンマッチを活用してください。  

2. **永続化処理はエッジ（インフラ層）に追いやり、アプリケーション層では呼ばない**でください。  
   - インフラ層に定義された永続化ロジックをUI（interface層）から直接呼び出す形を推奨します。  
   - アプリケーション層はあくまでドメインロジックのオーケストレーションやイベント発行が主体で、DB等への依存は切り離します。

3. **型定義は`interface`ではなく`type`を基本とし、変更不可の箇所には`Readonly<...>`を活用**してください。  
   - ReactのPropsやユースケースの引数・戻り値なども、可能な限り`type`と`Readonly`で定義します。

4. **ドメイン層ではなるべくプリミティブ型を使わず、ブランド型・シンボル型で明確に型を区別**してください。  
   - 例: `type FeedId = string & { readonly brand: unique symbol }` や `Symbol`などを用いてID同士の取り違えを防止します。

5. **異なるコンテキスト間ではドメインを直接参照せず、唯一参照を許可するのはIDのみ**としてください。  
   - そのほかの情報はドメインイベントを介して渡す方針とし、コンテキスト間の結合を極力下げます。  
   - これにより、ドメインロジックの肥大化や混在を避けつつ疎結合を実現します。

6. **`rxjs`を活用し、イベント駆動型の処理を実装**します。  
   - ドメインイベントのストリーム管理や非同期通知など、`rxjs`のオブザーバブルを用いて柔軟に拡張できるようにしてください。

